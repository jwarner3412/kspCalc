<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="sat-calc-input">
  <template>
    <style>
      :host {
        display: block;
      }
      calc-sol-select,
      calc-body-select {
        display: inline-block;
        width: 40%;
        margin: 0 2.5%;
      }
    </style>

    <sat-calc-options sol-list="[[solList]]"
      body-list="[[bodyList]]"
      label="[[targLabel]]"
      reset="{{reset}}"
      sol-input="{{solInput}}"
      body-input="{{bodyInput}}"
      sat-count="{{satCount}}"
      prec-input="{{precInput}}"
      targ-by="{{targBy}}"></sat-calc-options>

    <sat-calc-target user-val="{{inputValue}}"
      min="[[min]]" max="[[max]]"></sat-calc-target>

    <!-- <sat-calc-action baseUrl="{{baseUrl}}"
      disable="{{geoDisable}}"
      geo-set="{{geoSet}}"
      ></sat-calc-action> -->

    <sat-calc-data user-options="[[options]]"
      user-target="[[targetValue]]"
      result="{{results}}"
      range="{{range}}"></sat-calc-data>

    <iron-ajax auto
      url="../../dataList.json"
      handle-as="json"
      last-response={{data}}
      debounce-duration="300"></iron-ajax>

  </template>
  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'sat-calc-input',

      properties: {
        // mediators
        solList: {
          type: Array,
          computed: '_returnSolList(data)',
          notify: true
        },

        bodyList: {
          type: Array,
          computed: '_returnBodyList(data, solInput)',
          notify: true
        },

        // sends alt and per values to targby el
        targLabel: {
          type: Object,
          computed: 'getLabel(results.target)',
          notify: true
        },

        // checks for reset and geo flags, sets input and target values accordingly
        targetValue: {
          type: Number,
          computed: '_validateTarget(inputValue, targBy, reset, range, geoSet)',
          notify: true
        },

        // for all the maths
        options: {
          type: Object,
          computed: '_returnOptions(solInput, bodyInput, satCount, precInput, targBy, data)',
          notify: true
        },

        // out to sibling for results
        results: {
          type: Object,
          notify: true
        },

        min: {
          type: Number,
          computed: '_returnRange(range, targBy, "min")',
          notify: true
        },

        max: {
          type: Number,
          computed: '_returnRange(range, targBy, "max")',
          notify: true
        }
      },

      _returnSolList: function(d) {
        var solList = [];
        d.forEach(function(e, i, a) {
          if (e.name) {
            solList.push(e.name);
          }
        });
        return solList;
      },

      _returnBodyList: function(d, i) {
        var bodyList = [];
        d[i].bodys.forEach(function(e, i, a) {
          bodyList.push(e.bodyName);
        });
        return bodyList;
      },

      _returnOptions: function(sol, body, count, prec, targ, data) {
        var options = {
          body: data[sol].bodys[body],
          satCount: count,
          precInput: prec,
          targBy: targ
        };
        console.log(options);
        return options;
      },

      _returnRange: function(rng, targ, val) {
        if (targ == 'alt') {
          if (val == 'min') {
            return rng.min.alt;
          } else {
            return rng.max.alt;
          }
        } else {
          if (val == 'min') {
            return rng.min.per;
          } else {
            return rng.max.per;
          }
        }
      },

      getLabel: function(results) {
        var lbl = {
          alt: results.target.altM,
          per: results.target.per,
          time: results.target.time
        };
        return lbl;
      },

      _validateTarget: function(val, targ, res, rng, geoBool) {
        if (res) {
          if (targ == 'alt') {
            val = rng.min.alt;
          } else {
            val = rng.min.per;
          }
          res = false;
        }

        if (geoBool) {
          val = this.options.body.synodicDayS;
          geoBool = false;
        }

        if (targ == 'alt') {
          if (val < rng.min.alt) {
            val = rng.min.alt;
          }
          if (val > rng.max.alt) {
            val = rng.max.alt;
          }
        } else {
          if (val < rng.min.per) {
            val = rng.min.per;
          }
          if (val > rng.max.per) {
            val = rng.max.per;
          }
        }
        return val;
      }

    });
  })();
  </script>
</dom-module>
