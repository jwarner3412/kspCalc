<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="sat-calc-data">
  <script>
  (function() {
    'use strict';

    Polymer({
      is: 'sat-calc-data',

      properties: {
        userBody: {
          type: Object
        },

        userOptions: {
          type: Object
        },

        userTarget: {
          type: Number
        },

        minOrbit: {
          type: Object,
          computed: 'minMath(userOptions, userBody)'
        },

        maxOrbit: {
          type: Object,
          computed: 'maxMath(userOptions, userBody)'
        },

        minVal: {
          type: Number,
          computed: '_returnMinVal(userOptions.targBy, minOrbit)',
          notify: true
        },

        maxVal: {
          type: Number,
          computed: '_returnMaxVal(userOptions.targBy, maxOrbit)',
          notify: true
        },

        result: {
          type: Object,
          computed: 'takeSnap(userOptions, userBody, userTarget)',
          notify: true
        }
      },

      SnapShot: function(opt, body, val) {
        this.math = {};
        // Semi-Major-Axis
        this.math.calcSMA = function(alt, bodyRad) {
          var sma = (((2 * alt) + (2 * bodyRad)) / 2);
          return sma;
        };
        // Period
        this.math.calcPER = function(sma, Mu) {
          var p = 2 * Math.PI * Math.sqrt(Math.pow(sma, 3) / Mu);
          return p;
        };
        // Ra (for deployment orbit math)
        this.math.calcRa = function(per, rp, Mu, mply) {
          var muu = 2 * Mu;
          var muPow = Math.pow(muu, 1 / 3);
          var perPow = Math.pow(per, 2 / 3);
          var piPow = Math.pow(Math.PI, 2 / 3);
          if (mply) {
            piPow *= mply;
          }
          var a = perPow * muPow / piPow - rp;
          return a;
        };

        // sets numbers to 3 decimal places
        this.math.setDec = function(value) {
          return Math.round(value * 1000) / 1000;
        };

        // intakes seconds, outputs d:h:m:s in an array
        this.math.parseSec = function(s, bodyT) {
          var sec = Math.floor((s % 60) * 1000) / 1000;
          var min = Math.floor((s % 3600) / 60);
          var hour = Math.floor((s % bodyT) / 3600);
          var day = Math.floor(s / bodyT);
          var time = [day, hour, min, sec];
          return time;
        };

        this.body = body;
        var prec = parseFloat(opt.precInput);
        var satCnt = parseInt(opt.satCount, 10);
        var known = parseFloat(val);
        var type = opt.targBy;

        var rad = this.body.radiusM;
        var mu = this.body.MUms3;
        var dayS = this.body.siderealDayS;
        if (type !== 'alt') {
          known = this.math.setDec(this.math.calcRa(known, rad, mu, 2));
        }

        this.target = {};
        this.target.altM = known;
        this.target.semiMajAxis = this.math.calcSMA(known, rad);
        this.target.per = this.math.setDec(this.math.calcPER(this.target.semiMajAxis, mu));
        this.target.time = this.math.parseSec(this.target.per, dayS);
        this.target.orbSpeed = Math.sqrt(mu * (1 / this.target.semiMajAxis));

        this.deploy = {};
        this.deploy.ratio = 1 + 1 / satCnt;
        this.deploy.per = this.target.per * this.deploy.ratio;
        this.deploy.time = this.math.parseSec(this.deploy.per, dayS);
        this.deploy.Rp = this.target.semiMajAxis;
        this.deploy.Ra = this.math.calcRa(this.deploy.per, this.deploy.Rp, mu);
        this.deploy.semiMajAxis = (this.deploy.Rp + this.deploy.Ra) / 2;
        this.deploy.Pe = this.target.altM;
        this.deploy.Ap = this.deploy.Ra - rad;
        var a = (2 / this.deploy.Rp - 1 / this.deploy.semiMajAxis);
        this.deploy.obtSpdPE = Math.sqrt(mu * a);
        this.deploy.circDVreq = this.target.orbSpeed - this.deploy.obtSpdPE;

        this.satInfo = {};
      },

      takeSnap: function(opt, body, val) {
        if (val <= this.minVal) {
          return this.minOrbit;
        } else if (val >= this.maxVal) {
          return this.maxOrbit;
        } else if (this.result) {
          if (val == this.result.target.altM && opt.targBy == 'alt') {
            return this.result;
          } else if (val == this.result.target.per && opt.targBy == 'per') {
            return this.result;
          } else {
            return new this.SnapShot(opt, body, val);
          }
        } else {
          return new this.SnapShot(opt, body, val);
        }
      },

      minMath: function(opt, body) {
        // returns radians lolz
        Math.radians = function(degrees) {
          return degrees * Math.PI / 180;
        };

        // calculates minimum & max orbit based on satCount and body parameters
        // does math, and snapShots a minOrbit obj and maxOrbit obj
        var opts = {
          precInput: opt.precInput,
          satCount: opt.satCount,
          targBy: 'alt'
        }

        var bodyR = body.radiusM;
        var minPE = body.minPE + 1000;
        var precInput = parseFloat(opt.precInput);
        var satCount = parseInt(opt.satCount, 10);

        var rads = Math.radians(180 / satCount + precInput);
        var minAlt = Math.max(Math.ceil(bodyR / Math.cos(rads) - bodyR), minPE);

        var minOrbit = new this.SnapShot(opts, body, minAlt);

        return minOrbit;
      },

      maxMath: function(opt, body) {
        var opts = {
          precInput: opt.precInput,
          satCount: opt.satCount,
          targBy: 'per'
        }
        var bodyR = body.radiusM;
        var maxAP = body.soiRadM;
        var precInput = parseFloat(opt.precInput);
        var satCount = parseInt(opt.satCount, 10);

        var ratio = 1 + 1 / satCount;
        var maxCircPer = (function(alt, b) {
          var tSM = Math.pow((((2 * alt) + (2 * b.radiusM)) / 2), 3);
          var perSecTot = 2 * Math.PI * Math.sqrt(tSM / b.MUms3);
          return perSecTot;
        })(maxAP, body);

        var maxPer = (maxCircPer / ratio) / ratio;

        var maxOrbit = new this.SnapShot(opts, body, maxPer);

        return maxOrbit;
      },

      _returnMinVal(opt, min) {
        if (opt == 'alt') {
          return min.target.altM;
        } else {
          return min.target.per;
        }
      },

      _returnMaxVal(opt, max) {
        if (opt == 'alt') {
          return max.target.altM;
        } else {
          return max.target.per;
        }
      },

      convert: function(opt, obj) {
        if (opt == 'alt') {
          return obj.target.per;
        } else {
          return obj.target.altM;
        }
      }

    });
  })();
  </script>
</dom-module>
